/**
 * @fileOverview Firestore Security Rules for Conecta IA.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for private data (users, sessions, messages),
 * allows public read access to knowledge sources, and restricts admin role access.
 * It adopts a prototyping approach, focusing on authorization and relationship integrity
 * while omitting detailed data shape validation for rapid iteration.
 *
 * Data Structure:
 * - /users/{userId}: Stores individual user profiles.
 * - /users/{userId}/sessions/{sessionId}: Stores sessions for each user.
 * - /users/{userId}/sessions/{sessionId}/messages/{messageId}: Stores messages within sessions.
 * - /knowledgeSources/{knowledgeSourceId}: Stores knowledge sources accessible to all users.
 * - /roles_admin/{userId}: Stores admin roles, accessible only to the assigned user.
 * - /fiscales/{fiscalId}: Stores information about polling supervisors. Write access is currently not permitted.
 *
 * Key Security Decisions:
 * - Users can only access their own profile data, sessions, and messages.
 * - Knowledge sources are publicly readable but writes are not permitted in this phase.
 * - Admin roles are only readable by the assigned user.
 * - Listing of user documents, sessions, and messages is allowed only by the owner.
 * - The /fiscales collection is currently read-only; writes are denied.
 *
 * Denormalization for Authorization:
 *  - For this version, we're assuming that the 'userId' is correctly placed in the path
 *    and that we can rely on request.auth.uid for authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by a signed-in user.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing document.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) Signed-in user can create their own profile if the userId matches their auth.uid. Example: A user with UID 'user123' can create a document at /users/user123.
     * @allow (get, list) Signed-in user can read their own profile.
     * @allow (update, delete) Signed-in user can update/delete their own profile if the userId matches their auth.uid. Example: A user with UID 'user123' can update the document at /users/user123.
     * @deny (create) User attempts to create a profile with a userId that does not match their auth.uid.
     * @principle Enforces document ownership for reads and writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user sessions.
     * @path /users/{userId}/sessions/{sessionId}
     * @allow (create) Signed-in user can create sessions under their own profile. Example: A user with UID 'user123' can create a document at /users/user123/sessions/session456.
     * @allow (get, list) Signed-in user can read sessions under their own profile.
     * @allow (update, delete) Signed-in user can update/delete sessions under their own profile. Example: A user with UID 'user123' can update the document at /users/user123/sessions/session456.
     * @deny (create) User attempts to create a session under another user's profile.
     * @principle Enforces document ownership and restricts access to a user's own data tree.
     */
    match /users/{userId}/sessions/{sessionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for messages within a session.
     * @path /users/{userId}/sessions/{sessionId}/messages/{messageId}
     * @allow (create) Signed-in user can create messages within their own sessions. Example: A user with UID 'user123' can create a document at /users/user123/sessions/session456/messages/message789.
     * @allow (get, list) Signed-in user can read messages within their own sessions.
     * @allow (update, delete) Signed-in user can update/delete messages within their own sessions. Example: A user with UID 'user123' can update the document at /users/user123/sessions/session456/messages/message789.
     * @deny (create) User attempts to create a message in another user's session.
     * @principle Enforces document ownership and restricts access to a user's own data tree.
     */
    match /users/{userId}/sessions/{sessionId}/messages/{messageId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for knowledge sources.
     * @path /knowledgeSources/{knowledgeSourceId}
     * @allow (get, list) Any signed-in user can read knowledge sources.
     * @deny (create, update, delete) Writes are disallowed for this version.
     * @principle Allows public read access to knowledge sources.
     */
    match /knowledgeSources/{knowledgeSourceId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for admin roles.
     * @path /roles_admin/{userId}
     * @allow (get) The assigned user can read their own admin role.
     * @deny (list, create, update, delete) Listing, creation, updating, and deletion are disallowed.
     * @principle Restricts access to admin roles to the assigned user.
     */
    match /roles_admin/{userId} {
      allow get: if isOwner(userId);
      allow list, create, update, delete: if false;
    }

    /**
     * @description Rules for fiscales (polling supervisors).
     * @path /fiscales/{fiscalId}
     * @allow (get, list) Any signed-in user can read fiscal information.
     * @deny (create, update, delete) Writes are disallowed for this version.
     */
    match /fiscales/{fiscalId} {
        allow get, list: if isSignedIn();
        allow create, update, delete: if false;
    }
  }
}
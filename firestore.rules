/**
 * @fileOverview Firestore Security Rules for Conecta IA application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-generated content (sessions, messages) and restricts access to knowledge sources to admin users. User data is segregated under the /users/{userId} path. Admin privileges are determined by the presence of a document in the /roles_admin/{userId} collection.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles.
 * - /users/{userId}/sessions/{sessionId}: Stores user sessions.
 * - /users/{userId}/sessions/{sessionId}/messages/{messageId}: Stores messages within a session.
 * - /knowledgeSources/{knowledgeSourceId}: Stores knowledge sources, accessible only by admins.
 * - /roles_admin/{userId}: Indicates admin privileges; document content is irrelevant.
 *
 * Key Security Decisions:
 * - User data is strictly owned and controlled by the respective user.
 * - Knowledge sources are exclusively managed by admin users.
 * - Listing all users is disallowed.
 * - Authorization is primarily path-based and supplemented by admin role checks.
 * - The rules avoid using `get()` calls to maintain performance and support atomic operations.
 *
 * Denormalization for Authorization:
 * - Admin privileges are determined by the presence of a document in `/roles_admin/{userId}`, avoiding the need to read the user document.
 *
 * Structural Segregation:
 * - Private user data is stored under `/users/{userId}`, enabling secure list operations for the authenticated user.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles. Only the user themselves can read and write their profile.
     * @path /users/{userId}
     * @allow (create, update, get) if request.auth.uid == userId
     * @allow (list) if false
     * @deny (delete) always
     * @deny (create, update) if request.auth.uid != userId
     * @principle Enforces document ownership for writes; restricts listing of users.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Controls access to user sessions. Only the user themselves can read and write their sessions.
     * @path /users/{userId}/sessions/{sessionId}
     * @allow (create, get, list) if request.auth.uid == userId
     * @allow (update, delete) if request.auth.uid == userId && resource != null
     * @deny (create, update, delete) if request.auth.uid != userId
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/sessions/{sessionId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to messages within a session. Only the user themselves can read and write their messages.
     * @path /users/{userId}/sessions/{sessionId}/messages/{messageId}
     * @allow (create, get, list) if request.auth.uid == userId
     * @allow (update, delete) if request.auth.uid == userId && resource != null
     * @deny (create, update, delete) if request.auth.uid != userId
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/sessions/{sessionId}/messages/{messageId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to knowledge sources. Only admin users can read and write knowledge sources.
     * @path /knowledgeSources/{knowledgeSourceId}
     * @allow (get, list, create, update, delete) if isAdmin()
     * @deny (get, list, create, update, delete) if !isAdmin()
     * @principle Restricts access to admin-only content; uses admin role check.
     */
    match /knowledgeSources/{knowledgeSourceId} {
      function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
      }
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

        /**
     * @description Controls who can create a role.  If a document exists in this path, the user is an admin.
     * @path /roles_admin/{userId}
     */
    match /roles_admin/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
       allow get: if false;
       allow list: if false;
       allow create: if isOwner(userId);
       allow update: if false;
       allow delete: if false;
    }
  }
}